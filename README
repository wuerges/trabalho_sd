
================================================
Dependencies:

1) Available in ubuntu repositories:
omniidl
omniidl-python
python-omniorb
omniorb-nameserver

2) Not available in ubuntu repositories:
pyCSP 0.7.1: http://code.google.com/p/pycsp/ (.deb package available)

================================================
Instalation:

After installing omniorb you must configure it to use 
with this package.
Edit "/etc/omniORB.cfg", adding the following line:

InitRef = NameService=corbaname::localhost

Notice that localhost can be changed to wherever you run the message 
coordination server.

=================================================
Running:

The app wors with 1 server and 1 or more clients.

The server app must be run before the clients:

$ python server.py num_clients

num_clients is the number of clients the server will wait for
before allowing the clients to proceed.
New clients cannot be added during execution.

Client servers can be written based on the client.py and client_file.py examples.

=========== Hard coded client example ============
client.py comes with 4 preset behaviors, depending on the command
line argument passed.
With no command line arguments, it generates 5 random events (local or sends).
This example client.py also accepts 1 (only one) argument.
This argument activates 1 of 3 preset event lists: S1, S2, S3.

S1 = ( e11, m21, m31, e41, m51, m61)
S2 = ( e12, m22, e32, m42, m52, e62, m72)
S3 = ( m13, m23, e33, e43, m53, m63)

eXX are local events. mXX are send events.
Receive events are not explicit, they are generated by send events.

S3 configuration also has a special restriction:
It only procceds sending m53 after events e32 and m21 were generated.
For that it waits for events m42 and m21 (because event m42 is the first send event of S2 after e32).

=========== File reading client example ============
client_file.py reads the events from a file.
3 example files representing the above configurations are available:
process1.events, process2.events and process3.events.
Client_file.py reads from the standart input, so to use one of these files you can do this:

$ python client_file.py < process1.events

The events file uses the following syntax:

all_events ::= ( ( event | guarded_event ) "\n" ) *
local ::= "e.*"
send ::= "m.*"
event ::= local | send
guard ::= "[" ( send ",") * send "]"
guarded_event ::= guard "->" event


==================================================
API:

Different clients can be written.
A client structure is:

#-------------------------------------------------
# A callback.
# s is a reference to the message server
def a_callback(s):
  ...

coord = <CordinationServer CORBA remote reference>
ms = MessageServer(coord)
ms.start(a_callback)
#-------------------------------------------------

The MessageServer class has 3 public methods:
app_send, app_receive, app_local.

app_send(payload) : Sends a message to all other clients with the 
argument payload.

app_receive([timeout=0.5]) : Returns a tuple in the format (r, m)
r is 0 if it was a success and -1 if happened a timeout. 
m is the received payload (or "" in case of a timeout).
The parameter timeout is optional, it specifies the timeout in secconds
and has a default value of 0.5 if ommited.

app_local(payload) : Generates a local event with the argument payload.
